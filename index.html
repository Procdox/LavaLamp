<html>
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js">></script>
<script src="js/simplex-noise.min.js"></script>
</head>
<body>
<div id="board">
</div>
<script>
var marching_hash = [[],[[0,.5,.5,1]],[[.5,1,1,.5]],[[0,.5,1,.5]],
	[[1,.5,.5,0]],[[0,.5,.5,0],[1,.5,.5,1]],[[.5,1,.5,0]],[[0,.5,.5,0]],
	[[.5,0,0,.5]],[[.5,0,.5,1]],[[.5,0,1,.5],[.5,1,0,.5]],[[.5,0,1,.5]],
	[[1,.5,0,.5]],[[1,.5,.5,1]],[[.5,1,0,.5]],[]];
var grid_segments = [];
function generate_marching_border(grid,threshold){
	//takes in a set of 2-dimensional points (ignores extra dimensions)
	//generates a set of marching squares segments
	//links segments into border
	//returns simplified border
	
	var segments = [];
	var segment,score;
	for(var xx=0;xx<display_rows;xx++){
		for(var yy=0;yy<display_rows;yy++){
			grid_segments[xx][yy]=[];
			score = 0;
			if(grid[xx][yy]>threshold){score+=8;}
			if(grid[xx+1][yy]>threshold){score+=4;}
			if(grid[xx+1][yy+1]>threshold){score+=2;}
			if(grid[xx][yy+1]>threshold){score+=1;}
			for(var hl=0;hl<marching_hash[score].length;hl++){
				segment = marching_hash[score][hl].slice(0)
				segment[0]+=xx;
				segment[1]+=yy;
				segment[2]+=xx;
				segment[3]+=yy;
				grid_segments[xx][yy].push(segment);
				
				//segments.push(segment);
			}
			//grid_vectors[xx][yy] = marching_vectors[score];
			if(score%15!=0){
				segments.push([xx,yy]);
			}
		}
	}
	var paths = [];
	var x,y,unfound,path;
	while(segments.length>0){
		var current = segments.pop();
		x = current[0];
		y = current[1];
		if(grid_segments[x][y].length==0){continue;}
		if(grid_segments[x][y].length==2){
			segments.push(current);
		}
		path = [grid_segments[x][y].pop()];
		current = path[0];
		while(true){
			unfound = true;
			if(current[2]==x){
				for(var ii=0;ii<grid_segments[x-1][y].length;ii++){
					if(grid_segments[x-1][y][ii][0]==current[2]&&grid_segments[x-1][y][ii][1]==current[3]){
						unfound = false;
						current = grid_segments[x-1][y].splice(ii,1)[0];
						path.push(current);
						x-=1;
						break;
					}
				}
			}else if(current[2]==x+1){
				for(var ii=0;ii<grid_segments[x+1][y].length;ii++){
					if(grid_segments[x+1][y][ii][0]==current[2]&&grid_segments[x+1][y][ii][1]==current[3]){
						unfound = false;
						current = grid_segments[x+1][y].splice(ii,1)[0];
						path.push(current);
						x+=1;
						break;
					}
				}
			}else if(current[3]==y){
				for(var ii=0;ii<grid_segments[x][y-1].length;ii++){
					if(grid_segments[x][y-1][ii][0]==current[2]&&grid_segments[x][y-1][ii][1]==current[3]){
						unfound = false;
						current = grid_segments[x][y-1].splice(ii,1)[0];
						path.push(current);
						y-=1;
						break;
					}
				}
			}else if(current[3]==y+1){
				for(var ii=0;ii<grid_segments[x][y+1].length;ii++){
					if(grid_segments[x][y+1][ii][0]==current[2]&&grid_segments[x][y+1][ii][1]==current[3]){
						unfound = false;
						current = grid_segments[x][y+1].splice(ii,1)[0];
						path.push(current);
						y+=1;
						break;
					}
				}
			}
			if(unfound){
				break;
			}
		}
		paths.push(path);
	}
	return paths;
}
</script>
<script>


//custom variables
var svg_size = 900;
var display_rows = 200;
var noise_scale = 60;
var noise_epsilon = 0.1;
var cluster_colors = ["red","blue","green","yellow","orange","purple","tan","darkred",
	"darkblue","lightcoral","lightskyblue","plum","steelblue","forestgreen","hotpink","darksalmon",
	"firebrick","goldenrod","gold","lawngreen","blueviolet"];

//computed variables

var simplex = new SimplexNoise();
var display_scale = svg_size/display_rows;
var points = [];

function paths2string (paths, scale) {
  var svgpath = "", i, j;
  if (!scale) scale = 1;
  for(i = 0; i < paths.length; i++) {
    for(j = 0; j < paths[i].length; j++){
      if (!j) svgpath += "M";
      else svgpath += "L";
      svgpath += (paths[i][j][0] * scale) + ", " + (paths[i][j][1] * scale);
    }
    svgpath += "Z";
  }
  if (svgpath=="") svgpath = "M0,0";
  return svgpath;
}

var ntime=0;

colors = [20,30,10,80,60,50,30,20]
var x_off = 0;
var y_off = 0;
var x_vel = .2;
var y_vel = -.4;
var grid = [];
for(var xx=0;xx<=display_rows;xx++){
	var row=[];
	var mrow = [];
	//var vrow = [];
	for(var yy=0;yy<=display_rows;yy++){
		row.push(-1);
		mrow.push([]);
		//vrow.push([]);
	}
	grid_segments.push(mrow);
	//grid_vectors.push(vrow);
	grid.push(row);
}

var svg_header = '<svg width="'+svg_size+'" height="'+svg_size+'" id="board">';
var svg, epsilon,xx,yy,border,ct;
function iterate(){
	svg = svg_header;
	
	x_vel += Math.random()/20-.025;
	y_vel += Math.random()/20-.025;
	if(x_vel>.8){x_vel=.8;}
	if(y_vel>.8){y_vel=.8;}
	if(x_vel<-8){x_vel=-.8;}
	if(y_vel<-8){y_vel=-.8;}
	x_off += x_vel;
	y_off += y_vel;
	for(epsilon = 0;epsilon<4;epsilon++){
		colors[epsilon] = (colors[epsilon]+Math.floor(Math.random()*8-4)+360)%360;
		points = [];
		for(xx=1;xx<display_rows;xx++){
			for(yy=1;yy<display_rows;yy++){
				grid[xx][yy] = simplex.noise3D((xx+x_off)/noise_scale,(yy+y_off)/noise_scale,ntime);
			}
		}
		
		border = generate_marching_border(grid,epsilon*.4-.6);
		svg += '<path stroke="black" fill="hsl('+colors[epsilon]+',50%,50%)" stroke-width="0" d="' + paths2string(border, display_scale) + '"/>';
	}
	svg += '</svg>';
	colors[epsilon] = (colors[epsilon]+Math.floor(Math.random()*8-4)+360)%360;
	ct = 'hsl('+colors[epsilon]+',50%,50%)'
	$("#board").css("background-color",ct)
	$("#board")[0].innerHTML = svg;
	ntime+=.01;
	setTimeout(iterate,30);
}

iterate()



</script>
</body>